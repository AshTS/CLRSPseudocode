# Pseudo Code Visualizer

CLRS (Cormen, Leiserson, Rivest, and Stein) Introduction to Algorithms is a commonly used textbook for algorithms classes, and it has a standard notation for pseudocode to aid in understanding. This is an interpreter and visualizer for that pseudocode which allows the snippets to be executed, and stepped through line by line while getting a visual representation of the program state. In the examples directory are several algorithms transcribed from the book. There are some notable differences which are outlined later in this document.

![demonstration of the visual code stepper](https://i.imgur.com/PHhLEwP.png)

## Components

There are several components to this project, all of which are available as subcommands from the commandline, allowing one to look at how the interpreter or compiler is understanding the code given to it.

In order of the pipeline for processing input, the first component is the tokenizer.

### Tokenizer

The tokenizer breaks up the input file into atoms of text to later be parsed. These tokens come with location information which remains attached to this data for the duration of processing the file. This allows error messages (primarily in the interpreter, the virtual machine produces more obtuse error messages as its goal is not debugging but demonstration) which are clear and ideally helpful.

The tokenized output can be viewed by running

```none
$> cargo run -- ./test_code/test.ps
```

### Parser

The next step in the pipeline is the parser. The parser takes the tokens from the tokenizer and interprets them as a program. This is also the first place error messages start to show up, and will catch structural problems with programs.

To view the parsed output, run

```none
$> cargo run -- ./test_code/test.ps
```

this will produce a pretty-printed version of the parse tree representing the parsed program. This is produced using Rust's `dbg!` macro, and thus is somewhat verbose, but can be useful for understanding why a program may not work as intended.

#### Errors

Say the list of parameters for a function were malformed, and a comma was left out.

```none
...
Function(arg0, arg1 arg2, arg3)
...
```

If we were to attempt to parse this, the following error message is returned:

```none
Parsing Failed
error: expected symbol ')', got 'arg2'
  --> .\test_code\simple_test.ps:1:21
    |
1   | Function(arg0, arg1 arg2, arg3)
    |                     ^^^^ expected symbol ')'

error: expected indented block
  --> .\test_code\simple_test.ps:1:21
    |
1   | Function(arg0, arg1 arg2, arg3)
    |                     ^^^^
    = help: make sure blocks are denoted with further levels of indentation
```

These error messages are intended to be almost identical in style to those produced by the Rust compiler, as those error messages provide the space for plenty of context and a visual representation of the problem. A colored version of this output makes this even clearer:

![the error message above shown with the colored output, closely resembling Rust error messages](https://imgur.com/mnWiaUF.png)

The parser errors are intended to be as useful as possible, however, due to the akward nature of the pseudocode from the book, the parser will often have trouble understanding how to recover after an error, so the first error message may end up being followed by increasingly nonsensical errors as the parser tries to understand the remaining tokens. This can be seen in the above example as the parser expects the function to begin after the expected `)` token.

### Interpreter

Now, we come upon a fork in the road. This is because this project contains two ways to execute the pseudocode. The first is using the interpreter. This method walks through the parse tree generated by the parser, executing each node one at a time. This recursive process has some downsides, one is that it makes heavy use of the stack, and even a mildly recursive algorithm in pseudocode can cause issues with the stack. However, this method is also more focused on error messages, and will produce more informative error messages than the virtual machine.

To run the interpreter, use the following:

```none
$> cargo run -- execute ./test_code/math.ps
```

This will run the `Test` function, or return an error saying it was not defined. At the end of execution, the value returned by the `Test` function will be printed out, this is why many programs which don't produce output when successfully executed simply produce a `None` at the command line, as functions implicitly return an empty value.

It is at the execution stage when type errors are caught, for example, if one tries to add a number and a boolean, the following error is produced:

```none
error: cannot add values of type number and bool
  --> .\test_code\test.ps:2:13
    |
2   |     Print(1 + (1 == 2))
    |             ^ cannot add values of type number and bool
```

### Compiler

The second path one can take to execute a pseudocode program is to compile the pseudocode into an internal representation which allows the code to be stepped through using the virtual machine.

To view the compiled code, run

```none
$> cargo run -- compile ./examples/bubblesort.ps
```

This displays the code produced for each function, with the associated line numbers in the original pseudocode file marked.

### Virtual Machine

This compiled code is executed using the virtual machine which allows stepping through the compiled code and viewing the program state. Unfortunately, the step of compilation does remove some token location data which means some of the error messages produced are not on par with the interpreter.

To execute a program with the vm, run

```none
$> cargo run -- vm-run ./examples/heapsort.ps
```

In default mode, the view on the left is the original source code, and the view on the right is the current state of the variables. The variable values are highlighted whenever they are read from or written to. A value will appear yellow if written to, and blue if read from. Yellow will take priority as writes are viewed as more important to display.

In addition, any array object which has its `heapsize` parameter set will also render as a heap, making stepping through algorithms such as `heapsort` more intuitive.

If an experience similar to the `execute` subcommand is desired, using the `-sn` flags will supress the visualizer, and enable `no-wait` mode. The `-i` flag will also display the instructions as they are executed. Note that this will conflict with the visualizer and only has a noticible impact with paired with `-s`.

## Pseudocode Language

Unfortunately, there are some dissimilarities to the language presented in the book. The two primary ones are that construction of arrays instead requires the builtin `Array` function instead of magically happening, and there is some very nebulous syntax in teh book surrounding allocating new arrays.

To make this demonstration language executable, several functions are added for convienience, or to make programs work at all.

Among these are `Array` which produces an array containing its parameters, `Print`, which displays its arguments, and `AssertEqual` which can be used to run tests and produce an error if its parameters are not equal.

There are some features preented in the book not implemented yet, most notable are strings and the ability to produce custom runtime errors. These may be added depending on how useful they would be for understanding those algorithms.

The `exchange` function presented in the book is also not present in this implementation, this is becuase it would have to behave as a macro (similar to the short circuiting logical and / logical or) since all arguments are passed by value.
